<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LRD 1024 bytes 2023</title>
</head>

<body>
  <script>
    // emulate the js1k shim
    const d = document
    const b = d.body

    let a = d.createElement('canvas')
    let c = a.getContext('2d')

    b.append(a)

    a.width = innerWidth
    a.height = innerHeight
  </script>


  <script>
    // nb later on when golfing consider packing these into a single string and
    // see if regpack likes that - sometimes it prefers separate consts or inline
    // literals
    //
    // stat related
    const $ = '💰'
    const weapon = '🗡️'
    const shield = '🛡️'
    const rogue = '🍀'
    const fighter = '💪'
    const magic = '🔮'
    // locations
    const castle = '🏰'
    const shop = '🏪'
    const healer = '🏥'
    const forest = '🌲'
    // boss
    const dragon = '🐉'

    // hang loose
    const rad = '🤙'
    // normal monsters
    //
    // level 1
    const bat = '🦇'
    const rat = '🐀'
    const snake = '🐍'
    // level 2
    const clown = '🤡'
    const goblin = '👺'
    const spider = '🕷️'
    // level 3
    const wolf = '🐺'
    const ghost = '👻'
    const skeleton = '💀'
    // level 4
    const troll = '👹'
    const devil = '😈'
    const bear = '🐻'
    // level 5
    const zombie = '🧟'
    const cyclops = '👁️'
    const alien = '👾'
    // encounters, good luck
    const unicorn = '🦄'
    const fairy = '🧚'
    const rainbow = '🌈'
    // encounters, bad luck
    const web = '🕸️'
    const trap = '🕳️'
    const vampire = '🧛'
    // concepts
    const health = '❤️'
    const attack = '⚔️'
    const dead = '☠️'
    const win = '🏆'
    const look = '👀'
    const visit = '💨'
    const nope = '🔒'
    const decision = '🤔'
    const place = '🗺️'
    const lucky = '🍀'
    const unlucky = '😭'
    const time = '⏰'
    const level = '🎚️'
    const up = '👆'
    const gym = '🏋️'
    const dice = '🎲'
    const ws = ' '
    const nl = '\n'

    // shop prices, levels, etc - all use this for scaling - will need tweaking
    const scaling = [0, 128, 512, 1024, 4096, 16384, 33768]

    // let d[ _p_class ]
    // let d[ _p_$ ]
    // let d[ _p_atk ]
    // let d[ _p_hp ]
    // let d[ _p_hpmax ]
    // let d[ _p_weapon ]
    // let d[ _p_shield ]
    // let d[ _p_level ]
    // let d[ _p_exp ]
    // let d[ _p_turns ]
    // let d[ _p_location ]

    const _p_class = 0
    const _p_$ = 1
    const _p_atk = 2
    const _p_hp = 3
    const _p_hpmax = 4
    const _p_weapon = 5
    const _p_shield = 6
    const _p_level = 7
    const _p_exp = 8
    const _p_turns = 9
    const _p_location = 10

    // forest encounter state
    // monster emoji
    // let d[ _f_class ]
    // // reward $ and xp
    // let d[ _f_$]
    // let d[ _f_exp]
    // // monster atk
    // let d[ _f_atk]
    // // monster hp
    // let d[ _f_hp]
    // // monster dmg - for player it's d[ _p_level ] + 1 + d[ _p_weapon ], for monster just a num
    // let d[ _f_dmg]

    const _f_class = 11
    const _f_$ = 12
    const _f_exp = 13
    const _f_atk = 14
    const _f_hp = 15
    const _f_dmg = 16

    // // dice
    // let d[ _die_0]
    // let d[ _die_1]
    // let d[ _die_2]

    const _die_0 = 17
    const _die_1 = 18
    const _die_2 = 19

    const appendButton = (
      label = attack,
      onclick = () => {
        d[ _p_location ] = label
        tick()
      },
      suffix = ws
    ) => {
      c = d.createElement('button')
      c.onclick = onclick
      c.append(label)
      a.append(c, suffix, nl)
    }

    const tick = () => {
      // rogues are luckier - they have a chance to reroll 1s
      // therefore, 1 or a low value should always be bad, and high values
      // should always be good
      d[ _die_0] = ((Math.random() * 6) | 0) + 1
      d[ _die_1] = ((Math.random() * 6) | 0) + 1
      d[ _die_2] = ((Math.random() * 6) | 0) + 1
      if (d[ _p_class ] === lucky && d[ _die_0] == 1) d[ _die_0] = ((Math.random() * 6) | 0) + 1
      // don't reroll the enemy dice in attacks, jebus! one expecption!
      if (d[ _p_class ] === lucky && d[ _die_1] == 1) d[ _die_1] = d[ _p_location ] == attack ? d[ _die_1] : ((Math.random() * 6) | 0) + 1
      if (d[ _p_class ] === lucky && d[ _die_2] == 1) d[ _die_2] = ((Math.random() * 6) | 0) + 1

      a.remove()
      a = d.createElement('pre')
      b.append(a)

      a.append(lucky + dragon + ws + d[ _p_location ], nl)

      if (d[ _p_location ] == decision) {
        // init player
        d[ _p_class ] = decision
        d[ _p_$ ] = 25
        d[ _p_atk ] = 5
        d[ _p_hp ] = d[ _p_hpmax ] = 10
        d[ _p_weapon ] = 0
        d[ _p_shield ] = 0
        d[ _p_level ] = 0
        d[ _p_exp ] = 0
        d[ _p_turns ] = 0

        a.append(decision, nl)

        // choose rogue
        appendButton(
          rogue,
          () => {
            d[ _p_class ] = rogue

            d[ _p_location ] = castle
            tick()
          }
        )

        // choose fighter
        appendButton(
          fighter,
          () => {
            d[ _p_class ] = fighter
            d[ _p_atk ] = d[ _p_atk ] + 1

            d[ _p_location ] = castle
            tick()
          }
        )

        // choose magic
        appendButton(
          magic,
          () => {
            d[ _p_class ] = magic
            d[ _p_hp ] = d[ _p_hpmax ] = d[ _p_hpmax ] + 2

            d[ _p_location ] = castle
            tick()
          }
        )
      }
      // these are exclusive anyway so check if removing else is better for regpack later
      else if (d[ _p_location ] == castle) {
        // do castle stuff 

        a.append(decision, nl)

        // weapon shop
        // can buy if not max and if have money
        appendButton(
          weapon + (d[ _p_weapon ] + 1),
          () => {
            if (!(d[ _p_weapon ] == 5 || d[ _p_$ ] < scaling[d[ _p_weapon ] + 1])) {
              // begin custom shop action
              d[ _p_$ ] = d[ _p_$ ] - scaling[d[ _p_weapon ] + 1]
              d[ _p_weapon ] = d[ _p_weapon ] + 1
              d[ _p_atk ] = d[ _p_atk ] + 1
              // end custom shop action

              d[ _p_location ] = castle
              tick()
            }
          },
          (d[ _p_weapon ] == 5 || d[ _p_$ ] < scaling[d[ _p_weapon ] + 1]) ?
            nope + $ + scaling[d[ _p_weapon ] + 1] :
            $ + scaling[d[ _p_weapon ] + 1]
        )

        // shield shop
        // can buy if not max and if have money
        appendButton(
          shield + (d[ _p_shield ] + 1),
          () => {
            if (!(d[ _p_shield ] == 5 || d[ _p_$ ] < scaling[d[ _p_shield ] + 1])) {
              // begin custom shop action
              d[ _p_$ ] = d[ _p_$ ] - scaling[d[ _p_shield ] + 1]
              d[ _p_shield ] = d[ _p_shield ] + 1
              d[ _p_hpmax ] = d[ _p_hpmax ] + 2
              d[ _p_hp ] = d[ _p_hp ] + 2
              // end custom shop action

              d[ _p_location ] = castle
              tick()
            }
          },
          d[ _p_shield ] == 5 || d[ _p_$ ] < scaling[d[ _p_shield ] + 1] ?
            d[ _p_shield ] == 5 ?
              nope + shield :
              nope + $ + scaling[d[ _p_shield ] + 1] :
            $ + scaling[d[ _p_shield ] + 1]
        )

        // healer        
        appendButton(
          health + 1,
          () => {
            if (!(d[ _p_$ ] < 5 || d[ _p_hp ] == d[ _p_hpmax ])) {
              // begin custom shop action
              d[ _p_$ ] = d[ _p_$ ] - 5
              d[ _p_hp ] = d[ _p_hp ] + 1
              // end custom shop action

              d[ _p_location ] = castle
              tick()
            }
          },
          (d[ _p_$ ] < 5 || d[ _p_hp ] == d[ _p_hpmax ]) ? nope : $ + 5
        )

        // gym

        appendButton(
          level + (d[ _p_level ] + 1),
          () => {
            if (!(d[ _p_level ] == 5 || d[ _p_exp ] < scaling[d[ _p_level ] + 1])) {
              // begin custom shop action
              d[ _p_level ] = d[ _p_level ] + 1
              d[ _p_atk ] = d[ _p_atk ] + 1
              d[ _p_hp ] = d[ _p_hpmax ] = d[ _p_hpmax ] + 2
              // end custom shop action

              d[ _p_location ] = castle
              tick()
            }
          },
          (d[ _p_level ] == 5 || d[ _p_exp ] < scaling[d[ _p_level ] + 1]) ? nope + scaling[d[ _p_level ] + 1 ] : up
        )

        // forest
        // first use of short form, check if smaller to never use short form
        appendButton(forest)
      }
      else if (d[ _p_location ] == forest) {
        a.append(decision, nl)

        // explore
        appendButton(look)

        // look for dragon - locked until d[ _p_level ] == 5
        appendButton(
          dragon,
          () => {
            if (d[ _p_level ] == 5) {
              d[ _f_class ] = dragon
              d[ _f_$] = scaling[d[ _p_level ]] * 2
              d[ _f_exp] = scaling[d[ _p_level ]] * 2
              d[ _f_atk] = 14
              d[ _f_hp] = 50
              d[ _f_dmg] = 4 + d[ _p_level ] // 2 at level 0            

              d[ _p_location ] = attack
              tick()
            }
          },
          d[ _p_level ] == 5 ? look : nope
        )


        // back to castle
        appendButton(castle)
      }
      else if (d[ _p_location ] == look) {
        // if d[ _die_0] == d[ _die_1], random event
        // else, setup a battle and go to it


        if (d[ _die_0] == d[ _die_1]) {
          // super bad - vampire
          if (d[ _die_0] == 1) {

            a.append(
              d[ _die_2] == 1 ?
                unlucky + unlucky + vampire :
                unlucky + vampire,
              nl
            )

            // terrible - lost MAX HP
            if (d[ _die_2] == 1) {
              // draw message, take MAX HP and HP
              d[ _p_hpmax ] = d[ _p_hpmax ] - (d[ _p_level ] + 1)
              d[ _p_hp ] = d[ _p_hp ] - (d[ _p_level ] + 1)
            }
            // bad - lose HP 
            else {
              // draw message, take HP
              d[ _p_hp ] = d[ _p_hp ] - (d[ _p_level ] + 1)
            }
          }
          // bad
          else if (d[ _die_0] == 2) {
            // money fell down hole, lose some $
            // max can lose is 3 * d[ _die_2] * d[ _p_level ]
            // invert d[ _die_2] so that if eg rogue, less likely to be 6x
            d[ _die_2] = 7 - d[ _die_2]
            // reuse d[ _die_0]
            d[ _die_0] = 3 * d[ _die_2] * (d[ _p_level ] + 1)
            d[ _die_0] = d[ _die_0] > d[ _p_$ ] ? d[ _p_$ ] : d[ _die_0]

            d[ _p_$ ] = d[ _p_$ ] - d[ _die_0]

            a.append(unlucky + trap, nl)
          }
          // bad
          else if (d[ _die_0] == 3) {
            // got stuck in spider web, lose HP
            // draw message, take HP

            d[ _p_hp ] = d[ _p_hp ] - (d[ _p_level ] + 1)

            a.append(unlucky + web, nl)
          }
          // good
          else if (d[ _die_0] == 4) {
            // fairy - get d[ _die_2] HP, even over max
            // draw message, give HP

            d[ _p_hp ] = d[ _p_hp ] + d[ _die_2] * (d[ _p_level ] + 1)

            a.append(lucky + fairy, nl)
          }
          // good
          else if (d[ _die_0] == 5) {
            // rainbow = get some $
            // draw message, give $, link back to forest
            d[ _p_$ ] = d[ _p_$ ] + ((d[ _die_2] * scaling[d[ _p_level ] + 1] / 10) | 0)

            a.append(lucky + rainbow, nl)
          }
          // super good
          else if (d[ _die_0] == 6) {
            d[ _p_$ ] = d[ _p_$ ] + (d[ _die_2] * scaling[d[ _p_level ] + 1] / 10) | 0

            a.append(
              d[ _die_2] == 6 ?
              lucky + lucky + unicorn :
              lucky + unicorn,
              nl
            )

            // unicorn - get lots of stuff
            // amazing - get some ATK, some MAX HP
            if (d[ _die_2] == 6) {
              // draw message, give ATK, give MAX HP
              d[ _p_atk ] = d[ _p_atk ] + 1
              d[ _p_hpmax ] = d[ _p_hpmax ] + 2
              // 10 * the money
              d[ _p_$ ] = d[ _p_$ ] + d[ _die_2] * scaling[d[ _p_level ] + 1]
            }

            d[ _p_hp ] = d[ _p_hpmax ]
          }

          // handle if the event killed player
          if (d[ _p_hp ] <= 0) {
            appendButton(dead)
          }
          else {
            // back to forest
            appendButton(forest)
          }
        }
        else {
          // todo battle
          /*
            // level 1
            const bat = '🦇'
            const rat = '🐀'
            const snake = '🐍'
            // level 2
            const clown = '🤡'
            const goblin = '👺'
            const spider = '🕷️'
            // level 3
            const wolf = '🐺'
            const ghost = '👻'
            const skeleton = '💀'
            // level 4
            const troll = '👹'
            const devil = '😈'
            const bear = '🐻'
            // level 5
            const zombie = '🧟'
            const cyclops = '👁️'
            const alien = '👾'          
          */
          // choose a monster based on d[ _p_level ] and dice  
          if (d[ _p_level ] == 0 && d[ _die_0] < 3) {
            d[ _f_class ] = bat
          }
          else if (d[ _p_level ] == 0 && d[ _die_0] < 5) {
            d[ _f_class ] = rat
          }
          else if (d[ _p_level ] == 0) {
            d[ _f_class ] = snake
          }
          else if (d[ _p_level ] == 1 && d[ _die_0] < 3) {
            d[ _f_class ] = clown
          }
          else if (d[ _p_level ] == 1 && d[ _die_0] < 5) {
            d[ _f_class ] = goblin
          }
          else if (d[ _p_level ] == 1) {
            d[ _f_class ] = spider
          }
          else if (d[ _p_level ] == 2 && d[ _die_0] < 3) {
            d[ _f_class ] = wolf
          }
          else if (d[ _p_level ] == 2 && d[ _die_0] < 5) {
            d[ _f_class ] = ghost
          }
          else if (d[ _p_level ] == 2) {
            d[ _f_class ] = skeleton
          }
          else if (d[ _p_level ] == 3 && d[ _die_0] < 3) {
            d[ _f_class ] = troll
          }
          else if (d[ _p_level ] == 3 && d[ _die_0] < 5) {
            d[ _f_class ] = devil
          }
          else if (d[ _p_level ] == 3) {
            d[ _f_class ] = bear
          }
          else if (d[ _die_0] < 3) {
            d[ _f_class ] = zombie
          }
          else if (d[ _die_0] < 5) {
            d[ _f_class ] = cyclops
          }
          else {
            d[ _f_class ] = alien
          }

          /*
            // reward $ and xp
            let d[ _f_$]
            let d[ _f_exp]
            // monster atk
            let d[ _f_atk]
            // monster hp
            let d[ _f_hp]
            // monster dmg - for player it's d[ _p_level ] + 1 + d[ _p_weapon ], for monster just a num
            let d[ _f_dmg]          
          */

          // setup monster - we've used d[ _die_0] and d[ _die_1], leave d[ _die_2] for mage run
          d[ _f_$] = ((d[ _die_0] + d[ _die_1]) * scaling[d[ _p_level ] + 1] / 100) | 0
          d[ _f_exp] = ((d[ _die_1] + d[ _die_2]) * scaling[d[ _p_level ] + 1] / 100) | 0
          d[ _f_atk] = (7 - d[ _die_1]) + d[ _p_level ]
          d[ _f_hp] = ((7 - d[ _die_0]) + d[ _p_level ]) * 2
          d[ _f_dmg] = 2 + d[ _p_level ]

          // display monster
          a.append(d[ _f_class ] + ws + attack + d[ _f_atk] + ws + health + d[ _f_hp], nl)

          //line1 = decision
          a.append(decision, nl)

          // attack
          //appendButton( attack )
          appendButton()//short form - see if less bytes

          // can always run here - it's in attack that we check d[ _p_class ]
          // back to forest
          appendButton(forest, () => {
            d[ _f_class ] = 0

            d[ _p_location ] = forest
            tick()
          })
        }
      }
      else if (d[ _p_location ] == attack) {
        // todo: calc and display result of this battle round


        if ((d[ _p_atk ] + d[ _die_0]) == (d[ _f_atk] + d[ _die_1])) {
          // no hit      
          a.append(shield, nl)
        }
        else if ((d[ _p_atk ] + d[ _die_0]) > (d[ _f_atk] + d[ _die_1])) {
          // player hit monster          
          d[ _f_hp] = d[ _f_hp] - (2 + d[ _p_weapon ])

          a.append(d[ _f_class ] + health + -(2 + d[ _p_weapon ]), nl)
        }
        else {
          // monster hit    
          if ((d[ _f_dmg] - d[ _p_shield ]) <= 0) {
            // no hit      
            a.append(shield, nl)
          }
          else {
            d[ _p_hp ] = d[ _p_hp ] - (d[ _f_dmg] - d[ _p_shield ])

            a.append(d[ _p_class ] + health + -(d[ _f_dmg] - d[ _p_shield ]), nl)
          }
        }

        // display monster
        a.append( d[ _f_class ] + ws + attack + d[ _f_atk] + ws + health + d[ _f_hp], nl)

        if (d[ _p_hp ] <= 0) {
          // go to dead
          appendButton(dead)
        }
        else if (d[ _f_hp] <= 0) {
          // give rewards
          d[ _p_$ ] = d[ _p_$ ] + d[ _f_$]
          d[ _p_exp ] = d[ _p_exp ] + d[ _f_exp]

          // enemy died
          a.append(d[ _f_class ] + dead, nl)

          // show rewards
          a.append($ + d[ _f_$] + ws + level + d[ _f_exp], nl)

          if (d[ _f_class ] == dragon) {
            // exit to win
            appendButton(win)
          }
          else {
            // exit to forest
            appendButton(forest, () => {
              d[ _f_class ] = 0
              d[ _p_location ] = forest
              tick()
            })
          }
        }
        else {
          // next round, or run if allowed

          a.append(decision, nl)

          // attack
          //appendButton( attack )
          appendButton()//short form - see if less bytes

          appendButton(
            forest,
            () => {
              if (!(d[ _p_class ] == fighter || (d[ _p_class ] == magic && d[ _die_2] < 4))) {
                d[ _f_class ] = 0
                d[ _p_location ] = forest
                tick()
              }
            },
            (d[ _p_class ] == fighter || (d[ _p_class ] == magic && d[ _die_2] < 4) ) ? nope : ws
          )
        }
      }
      else if (d[ _p_location ] == dead) {
        a.append(dead, nl)
        // no outbound links, sorry, game over!
      }
      else if (d[ _p_location ] == win) {
        a.append(win, nl)
        // no outbound links, sorry, game over!        
      }

      // last, draw stats
      /*
      🍀 💰10 ⚔️7 ❤️18/18 🗡️0 🛡️0 🎚️1/0 🔒2/128 ⏰17
      */
      a.append(
        d[ _p_class ] + ws +
        $ + d[ _p_$ ] + ws +
        attack + d[ _p_atk ] + ws +
        health + d[ _p_hp ] + ws + d[ _p_hpmax ] + ws +
        weapon + d[ _p_weapon ] + ws +
        shield + d[ _p_shield ] + ws +
        level + d[ _p_level ] + ws + d[ _p_exp ],
        ws + time + d[ _p_turns ]
      )

      d[ _p_turns ] = d[ _p_turns ] + 1
    }
    d[ _p_location ] = decision
    tick()
  </script>
</body>

</html>